#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section
Desarrollo
\end_layout

\begin_layout Standard
El problema a resolver es dada una imágen digital tratar de representarla
 con caracteres ASCII.
\end_layout

\begin_layout Standard
Para esto se divide la imágen original en tantas sub-imágenes como caracteres
 de ancho y alto se desee y luego se elije el caracter que más se asemeje
 a la sub-imágen.
 Esto implica varios puntos relevantes, tanto la descomposición en sub-imágenes
 como la elección del caracter más representativo entre un conjunto de entrenami
ento de imágenes de caracteres ASCII.
\end_layout

\begin_layout Standard
Para la descomposición en sub-imágenes la primer restricción a tener en
 cuenta es que ésta debe ser del mismo tamaño que las imágenes de entrenamiento.
 Además la cantidad de caracteres en una línea 
(
\begin_inset Formula $ancho$
\end_inset

)
\lang english
 y la cantidad de líneas (
\begin_inset Formula $alto$
\end_inset

) de la imágen representada en ASCII debe ser configurable.
 Esto se traduce en una cantidad fija de sub-imágenes.
 Teniendo en cuenta que las imágenes de entrenamiento son de tamaño fijo
 
\begin_inset Formula $h\times w$
\end_inset

 se decidio escalar la imágen de entrada a 
\begin_inset Formula $h.ancho\times w.alto$
\end_inset

.
 De esta manera, tomado cuadrantes de tamaño 
\begin_inset Formula $h\times w$
\end_inset

 de la imagen escalada se consiguen 
\begin_inset Formula $ancho\times alto$
\end_inset

 sub-imágenes.
\end_layout

\begin_layout Standard
Para elegir el caracter más representativo se debe tener en cuenta que los
 caracteres ASCII no tienen colores.
 Por lo que es preferible analizar la imágen original convertida a escala
 de grises.
 Tanto las imágenes de entrenamiento como las sub-imágenes se representarán
 con un vector de 
\begin_inset Formula $m=h*w$
\end_inset

 coordenadas.
 Dado que 
\begin_inset Formula $m$
\end_inset

 puede ser un valor considerablemente grande, como sugiere el enunciado
 del trabajo práctico, se utiliza la técnica 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{PCA}
\end_layout

\end_inset

 para reducir la cantidad de coordenadas a considerar.
\end_layout

\begin_layout Standard
El primer paso es, a partir de los vectores de entrenamiento calcular la
 matriz de covarianza asociada 
\begin_inset Formula $M$
\end_inset

 y sus autovalores y autovectores.
 Para calcular los autovalores y autovectores, y teniendo en cuenta que
 
\begin_inset Formula $M$
\end_inset

 es simétrica, se utilizó el algoritmo 
\begin_inset Formula $QR$
\end_inset

.
 Dicho procesamiento es computacionalmente costoso y es independiente de
 la imágen que se desea transformar, por lo que se decidió guardar los resultado
s del cómputo de forma persistente en archivos de texto.
 También se decidió persistir la transformación característica asociada
 a los autovalores de la matriz aplicada a cada vector de entrenamiento,
 ya que ésto también es independiente de la imágen a procesar.
\end_layout

\begin_layout Standard
Luego, se aplica la transformación característica asociada a un subconjunto
 de 
\begin_inset Formula $k$
\end_inset

 elementos de los autovectores calculados a los vectores de cada cuadrante
 de la imágen.
 Y se lo compara con las primeras 
\begin_inset Formula $k$
\end_inset

 componentes de los vectores de entrenamiento ya transformados para elegir
 el más similar y asignarle el correspondiente caracter ASCII.
\end_layout

\begin_layout Subsection
Escalado de la imágen
\end_layout

\begin_layout Standard
Para escalar la imágen se utilizó la librería 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ImageMagick}
\end_layout

\end_inset

, en particular el comando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{convert}
\end_layout

\end_inset

.
 Al mismo tiempo que se escala la imágen se la tranforma a formato RAW en
 escala de grises.
\end_layout

\begin_layout Subsection
Descomposición QR
\end_layout

\begin_layout Standard
Para lograr la desomposición 
\begin_inset Formula $QR$
\end_inset

 de la matriz 
\begin_inset Formula $M$
\end_inset

 se decidió utilizar el método de las rotaciones de Givens.
\end_layout

\begin_layout Standard
La implementación que resulta de una traducción inmediata del método resultó
 ser muy poco eficiente.
 Luego de analizar las funciones que más costo computacional tenían, se
 encontró una mejora en la multiplicacion de las matrices de Givens generaría
 un aumento de performance considerable.
 Dada la particular forma de las matrices de Givens vale que:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
fila_{i}(G^{a,b}A)=\begin{cases}
fila_{i}(A) & i\neq a\wedge i\neq b\\
fila_{i}(G^{a,b})A & sino\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Aprovechando esto, para obtener el resultado sólo es necesario calcular
 la multiplicación de las filas 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 de la matriz, ahorrando así una gran cantidad operaciones en cada multiplicació
n.
\end_layout

\begin_layout Subsection
Algoritmo QR
\end_layout

\begin_layout Standard
Para realizar el cálculo de autovalores y autovectores, se realizó el algoritmo
 de 
\begin_inset Formula $QR$
\end_inset

 previamente explicado.
 Dicho algoritmo es un algoritmo iterativo, como tal se le debe definir
 un criterio de parada.
 Los considerados en este trabajo fueron:
\end_layout

\begin_layout Itemize
EsDiagonal: Se fija si la matriz 
\begin_inset Formula $A^{(i)}$
\end_inset

 es una matriz diagonal.
\end_layout

\begin_layout Itemize
EsTriangularSuperior: Se fija si la matriz 
\begin_inset Formula $A^{(i)}$
\end_inset

 es una matriz triangular superior.
\end_layout

\begin_layout Itemize
TieneDiferenteDiagonal: Se fija si la matriz 
\begin_inset Formula $A^{(i)}$
\end_inset

 y 
\begin_inset Formula $A^{(i-1)}$
\end_inset

tienen diferentes elementos en la diagonal.
\end_layout

\begin_layout Standard
Todos estos criterios tienen una cota de configurable para la tolerancia.
 Es decir, si la diferencia entre dos números es menor que la tolerancia,
 se consideran iguales.
 Finalmente se decidió que una combinación de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{EsDiagonal}
\end_layout

\end_inset

 y de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{TieneDiferenteDiagonal}
\end_layout

\end_inset

 es un buen criterio de parada, ya que si la matriz no es diagonal los autovecto
res no serán adecuados, y si los autovalores cambian entre una iteración
 y la siguiente (tienen diferente diagonal) estos valores no son suficientemente
 precisos.
\end_layout

\begin_layout Subsection
Semejanza entre vectores
\end_layout

\begin_layout Standard
Para definir cuál es el vector que más se asemeja a otro se realizó una
 busqueda lineal calculando la distancia entre dos vectores y quedandose
 con aquel de menor distancia.
 Para definir la distancia (
\begin_inset Formula $d)$
\end_inset

 entre dos vectores se definieron varios criterios teniendo en cuenta el
 dominio del problema.
\end_layout

\begin_layout Standard
Los criterios elegidos son todos una suma pesada de las distancias coordenada
 a coordenada, esto se consideró teniendo en cuenta que una componente del
 vector tiene mayor relevancia que las siguientes.
 Quedando la distancia entre dos vectores 
\begin_inset Formula $x,y\in\mathbb{R}^{n}$
\end_inset

:
\begin_inset Formula \[
d={\displaystyle \sum_{i=1}^{n}\beta_{i}|x-y_{i}|}\]

\end_inset


\end_layout

\begin_layout Itemize
Criterio 1: 
\begin_inset Formula $\beta_{i}=1$
\end_inset

 Esto resulta en la suma del modulo de las distancias.
\end_layout

\begin_layout Itemize
Criterio 2: 
\begin_inset Formula $\beta_{i}=i$
\end_inset

 Se priorizan las primeras componentes.
\end_layout

\begin_layout Itemize
Criterio 3: 
\begin_inset Formula $\beta_{i}=100^{n-i}$
\end_inset

 Se priorizan las primeras componentes.
\end_layout

\begin_layout Itemize
Criterio 4: 
\begin_inset Formula $\beta_{i}=2^{n-i}$
\end_inset

 Se priorizan las primeras componentes.
\end_layout

\begin_layout Itemize
Criterio 5: 
\begin_inset Formula $\beta_{i}=\frac{|a_{i}|}{{\displaystyle \sum_{j=1}^{n}|a_{j}|}}$
\end_inset

 Siendo 
\begin_inset Formula $a$
\end_inset

 el vector de autovalores ordenado de mayor a menor en módulo.
\end_layout

\begin_layout Standard
Finalmente el criterio utilizado es el criterio 5.
\end_layout

\begin_layout Subsection
Componentes principales
\end_layout

\begin_layout Standard
La cantidad de componentes principales a utilizar para procesar una imagen
 se decidió que sea un parámetro opcional, de no especificar ninguno, se
 utilizarán 10.
\end_layout

\end_body
\end_document
